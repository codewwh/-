#### 初学链表结点定义时，==不清楚下面这句代码的作用==：

LNode* A = (LNode*)malloc(sizeof(LNode));

#### 通过查阅相关资料后，总结出以下几点：

##### 1. 结点是内存中一片由用户分配的存储空间，只有一个地址来表示它的存在，我们会在分配链表结点空间的时候，同时定义一个指针，来存储这片空间的地址（这个过程通俗地讲叫“指针指向结点”），并且常用正在这个指针的名称来作为结点的名称。
##### 2. 函数声明void* malloc(size_t size);

备注：void* 表示未确定类型的指针，void* 可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者其他数据类型）。C,C++规定，void* 类型可以通过类型转换强制转换为任何其它类型的指针。
##### 3.返回值
如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当内存不再使用时，应使用free()函数将内存块释放。函数返回的指针一定要适当对齐，使其可以用于任何数据对象。 

##### 4.用法示例解释
malloc必须要由我们计算字节数，并且在返回后强行转换为实际类型的指针。

int* p;
p = (int*)malloc(sizeof(int) * 128);
//分配128个（可根据实际需要替换该数值）整型存储单元，并将这128个连续的整型存储单元的首地址存储到指针变量p中

double* pd = (double*)malloc(sizeof(double) * 12);
//分配12个double型存储单元，并将首地址存储到指针变量pd中。

#### malloc与内存
##### 1. 堆内存
假设从《The  C  Programming  Language》中推测正确，从未经动态分配的堆内存呈现上图形式。不连续的堆内存以“链”的形式联系：Heap1 -> Heap2 ->Heap3 ->Heap4->Heap1。将构成“堆链”的每个堆内存（如Heap1）称为“堆块”。malloc()/free()将每个堆块看作由两部分构成：“Header”和“可用堆内存”。在Header中包含了“指向下一个堆内存块的指针”、“本堆块的大小”。这样malloc()/free()就能更好地管理堆。
![image](http://upload.ouliu.net/i/201801230022339rvf9.jpeg)
##### 2. 堆内存分配
根据C中malloc(n)函数动态分配堆的机制：分配堆内存的时候就依序由低到高的地址搜索“堆链”中的堆块，搜索到“可用堆内存”满足n的堆块（如Heap1）为止。若Heap1的“可用堆内存”刚好满足n，则将Heap1从“堆链”中删除，同时重新组织各堆块形成新的“堆链”；若Heap1的“可用堆内存”大小大于n，则将malloc(n)申请到的“Header” + "可用堆内存"部分从Heap1中分裂，将剩余的Heap1堆内存块重新加入“堆链”中。经分裂后的堆内存也包含“Header”和“可用堆内存”两部分（如图Figure 2），然后将由malloc()分配得到的“可用堆内存”返回给用户。若某块堆内存空间比较大（如Heap1），能够满足较小内存的多次申请，那么由malloc(n)多次申请的堆内存块都是连续被分配给用户的（因为有Header，所以用户使用的堆地址不连续）。

为方便free()释放堆空间，经malloc(n)分配给用户的堆空间也隐含一个Header。如下图所示：
![image](http://upload.ouliu.net/i/20180123003257pzwir.jpeg)
由于Header的构成的内存对齐，C中malloc(n)函数分配的堆内存会大于等于Header + n。